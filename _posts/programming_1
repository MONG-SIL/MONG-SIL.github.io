1. 표지 (과제번호, 제출자 이름, 학번, 학과, 제출일자)
2. 문제 기술
3. 알고리즘 및 자료구조 설명
4. 느낀 점
5. 프로그램 코드  

과제번호: 1
제출자 : 최정환
학번 : 202003589
학과 : 컴퓨터 공학과
제출일자 : 2021-03-18


1) 2보다 큰 모든 짝수는 두 개의 소수(prime number)의 합으로 나타낼 수 있다는 Goldbach의 추측이 있다. 예를 들어 10 = 3 + 7, 20 = 7 + 13으로 나타낼 수 있다. 2보다 큰 임의의 짝수를 입력하여 이 짝수를 두 소수의 합으로 표현할 수 있는지를 결정하고 만약 표현할 수 있으면 차이가 가장 작은 두 소수의 합으로 나타내시오. 예를 들어 10 = 3 + 7 = 5 + 5이다. 문제에서 요구하는 결과는 5 + 5이다.

입력 받은 숫자가 소수인지 확인하는 함수를 사용했다.
위의 함수를 이용해 P라는 리스트 안에 2와 2000 사이의 소수를 넣어 둔 뒤, 
n이라는 변수에 int 형태로 숫자를 입력받아 받은 숫자의 중간부터 리스트 안의 소수와 비교해 
두 소수의 합이 입력받은 수이면 출력.



2-1) 4지 선다형 문제들의 정답과 문제별 배점이 주어질 때, 제출한 답안지의 점수를 계산하는 프로그램을 작성하시오.

split을 이용해 세 변수에 숫자를 리스트 형태로 받았다. 
그 뒤, 반복문을 사용해 정답 리스트와 답안지 리스트를 비교해 일치할 경우 score 변수에 더해 저장.
score 출력하면 끝.





2-2) 4지 선다형 문항들의 정답과 문항별 배점이 주어질 때, 제출한 n개의 답안지를 채점하여 최저 성적과 최고 성적을 출력하시오

각 문제의 정답과 배점을 리스트 형식으로 입력받음.
답안지의 수를 int 형식으로 입력받고 그 수만큼 반복문 반복.
최고점수, 최고점수를 찾는 문제이니 각 답안지를 정답과 비교하고, 각 문제를 채점하여 score에 저장.
채점이 끝난 후 score과 최고점수, 최저점수를 저장하는 변수를 비교해 최고, 최저 점수 변경후 출력.




2-3) 4지 선다형 문항들의 정답과 문항별 배점이 주어질 때, 제출한 n개의 답안지를 채점하여 (2) 정답률이 가장 낮은 문제의 번호를 출력하시오. 정답률이 가장 낮은 문제 여러 개일 경우 이 문제들의 번호를 오름차순으로 출력하시오. 

역시 리스트 형식으로 각 문제의 정답, 배점을 리스트에 저장.
답안지 수를 입력받고, 답안지를 입력받자마자 각 문제의 정답을 카운트.
카운트 리스트를 오름차순으로 정렬한 리스트의 0번째 원소는 가장 적게 맞춘 문제의 정답인 횟수.
카운트 리스트에서 가장 적게 맞춘 문제의(난이도가 가장 높은) 정답 횟수인 원소를 찾아 문제 번호 출력



3-1) 문자열이 회문이면 yes를 출력하고 그렇지 않으면 no를 출력하는 프로그램을 작성하시오. (대/소문자 구분하지 않음)

lower()함수를 이용해 모든 문자열을 소문자로 저장.
그 문자열을 매개변수로 문자열의 앞뒤를 비교해 회문인지 구분하는 함수에 넣음.
함수의 리턴 값에 따라 yes, no 출력.


3-2) 문자열 s의 서로 다른 모든 회문 부문자열(substring)을 사전식 순서대로 출력하는 프로그램을 작성하시오. 단, 대/소문자 구분하지 않으며, 출력하는 회문 부문자열의 각 문자는 소문자이다. sort 함수를 사용하여도 좋음)

역시 lower()함수를 이용해 모든 문자열을 소문자로 저장.
그 문자열을 매개변수로 문자열의 앞뒤를 비교해 회문인지 구분하는 함수에 넣음.
모든 부문자열을 회문인지 확인해 리스트 안에 넣어야 하기 때문에 중첩반복문을 사용해 첫번째 문자열부터 끝까지 모두가 회문인지 탐색
이때 문자열 슬라이싱을 통해 부문자열 구분을 도움.
중복이나, 빈칸을 구분하는 내용도 추가하여 알파벳 순서대로 정렬하여 출력.





느낀점 : 오랜만에 파이썬을 이용해 프로그램 코드를 짜니 어색했다. 코딩하는 중간에 for 반복문을 많이 사용하는 부분이 있었는데, 이 부분에서 효율적인 코딩을 위한 방법이 있었던 것 같은데 까먹었다. 지속적인 코딩을 해서 잊어버리는 내용이 없게 해야겠다고 느꼈다. 

프로그램 코드

1.
def prime_number(n) : # n이 소수인지 확인하는 함수, P리스트에 소수를 미리 넣어놓기 위해.
	for i in range(2, int(n**0.5+1)) :
			if n % i == 0 : return False
	return True

P = [] # 소수를 미리 넣어놓을 리스트
for i in range(2, 2001) : # 2000까지 숫자를 검사
	if prime_number(i) : P.append(i) # i가 소수이면, P 리스트에 소수 들어가게 함


n = int(input()) # 합으로 표현할 수 int 형식으로 입력받기 

for i in range(n//2, 1, -1) : #입력받은 숫자를 2로 나눈 부분부터 1까지 하나씩 내려가며 찾음, 여기부터 찾아야 소수 사이의 차이가 적음
	if i in P and n-i in P : # P리스트 안에 숫자가 있는지 확인 
		a, b = i, n-i #P안에 있으면 a에 작은 소수, b에 큰 소수 넣어서 반복문 끝
		break
	else : continue # 없을경우 아무 일 안하고 다시 반복
print(a, b)



2-1.
A = input().split(' ') # 정답을 입력받는 리스트
S = input().split(' ') # 배점을 입력받는 리스트
K = input().split(' ') # 답안지를 입력받는 리스트
score = 0 # 점수를 저장할 변수 

for i in range(len(A)): # 문제 수만큼 반복 
	if A[i] == K[i]: # 정답과 답안지가 같으면,
		score += int(S[i]) #그 문제의 배점만큼 점수를 더함
print(score) # 점수 출력
	

2-2.
A = input().split(' ') # 답안을 입력받는 리스트
S = input().split(' ') # 배점을 입력받는 리스트
K_num = int(input()) # 답안지 숫자
score = 0 # 현재 답안지 점수
H_score = 0 #최고점수 저장 변수
L_score = 100 #최저점수 저장 변수

for j in range(K_num): #답안지 숫자만큼 입력 반복
	K = input().split(' ') #답안지 입력받는 리스트 ( 매번 새로워짐 )
	for i in range(len(A)): #문제 수만큼 반복
		if A[i] == K[i]: #답안과 정답이 같으면 
			score += int(S[i]) #그 문제의 배점만큼 점수를 더함
	if score >= H_score : #현재 답안지의 점수가 최고점수보다 낮으면 
		H_score = score #현재 답안지의 점수가 최고점수 
	if score <= L_score : #현재 답안지의 점수가 최저점수보다 높으면
		L_score = score #현재 답안지의 점수가 최저점수
	score = 0  # 다음답안지 점수 받기위해 0으로 초기화
	
print(L_score, H_score) # 최저점수, 최고점수 출력


2-3.
A = input().split(' ') # 답안지를 입력받는 리스트
S = input().split(' ') # 배점을 입력받는 리스트
K_num = int(input()) #답안지 개수 입력
count = [] # 문제를 맞춘 횟수를 저장하는 리스트
s_count = []# 오름차순으로 정렬된 count리스트 

for i in range(len(A)):  # 각 문제당 맞춘 횟수 카운트위해 문제 수만큼 0으로 초기화
	count.append(0)

for j in range(K_num): # 답안지 수만큼 반복
	K = input().split(' ') # 답안지 입력받는 리스트
	for i in range(len(A)): #문제 수만큼 반복
		if A[i] == K[i]: # 답안지와 정답이 같으면
			count[i] = int(count[i])+1 #문제 맞춘 횟수 카운트

s_count=sorted(count) # 오름차순으로 정렬된 count리스트 s_count[0]이 가장 난이도가 높은 문제를 맞춘 횟수

for i in range(len(A)): #문제 수만큼 반복
	if count[i] == s_count[0]: #문제 번호대로 카운트 된 카운트리스트의 카운트 횟수와 가장 난이도가 높은 문제(s_count[0])를 맞춘 횟수가 같으면
		print(i+1, end=" ") # 띄어쓰기로 구분해 문제 번호를 출력
	


3-1.
word = input() #회문인지 구별할 단어 입력
word = word.lower() #받은 단어 소문자로 바꾸기

def palindrome(word): #word가 매개변수인 함수
	for i in range(len(word) // 2): # 0부터 문자열 길이의 절반만큼 반복
		if word[i] != word[-1 - i]: # 왼쪽 문자와 오른쪽 문자를 비교 했을 때 , 다르면 
			return False # 함수 값으로 False 리턴 
	return True # 다르지 않을 경우 함수값으로 True 출력

if palindrome(word): #함수 값이 True면 yes, False면 no 출력.
	print('yes')
else:
	print('no')


3-2.
string = input() #문자열 입력받음
string=string.lower()#문자열 모두 소문자로 변환
p_list=[] # 모든 substring을 저장할 리스트
num=0 # 문자열 구분을 도와줄 변수 

def s_list(p_list,word): # list안에 word가 있으면 false 반환하는 함수 (중복 제거 위함)
	for i in range(len(p_list)): #리스트 원소 수만큼 반복
		if p_list[i] == word: # word안에 있는 부문자열이 list안에 있으면, 넣지않음
			return False
	return True # 아무 문제 없으면 True반환

def palindrome(word): #word가 매개변수인 회문인지 구분하는 함수 
	for i in range(len(word) // 2): # 0부터 문자열 길이의 절반만큼 반복
		if word[i] != word[-1 - i]: # 왼쪽 문자와 오른쪽 문자를 비교 했을 때 , 다르면 
			return False # 함수 값으로 False 리턴 
	return True # 다르지 않을 경우 함수값으로 True 출력

for i in range(len(string)): # 문자열끝까지 회문 구분위해 중첩반복문 사용
	for j in range(len(string)+1):
		if j == 0: # 0인경우는 word에 아무것도 들어가지 않음
			continue # 반복문 반복
		else:
			word = string[num:j] # 회문인지 문자열을 끊어서 구분하기 위함
			if palindrome(word) and word != '' and s_list(p_list,word): #회문이고, 빈칸이 아니고, 이미 list에 넣지 않았으면, 리스트에 추가
				p_list.append(word)
			else: #위의 이유가 아니라면
				continue #넘어가기
	num += 1
	
p_list.sort() #부문자열을 담은 리스트를 알파벳 순서대로 정렬

for c in range(len(p_list)): # plist 원소 수만큼 반복
	print(p_list[c], end=' ') # 줄바꿈 없이 원소 출력

